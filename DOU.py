# -*- coding: utf-8 -*-
"""Cópia de DOU.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gJHDZtuGvV0a9t6KWFaL-l8tecb_FjJB

#Importações e Configuração de Ambiente
"""

# Conteúdo que você deseja colocar no .env
env_content = """
EMAIL=eixoraspagem@hotmail.com
SENHA_EMAIL=Eixo2024@
PLANILHA=1NAym6z6aBmJylXURA65jil1D5wC11P4ZiBKy3dmsl4M
DESTINATARIOS=mariaeduarda.marques@eixoestrategia.com
"""

# Escrever o conteúdo no arquivo .env
with open('.env', 'w') as file:
    file.write(env_content.strip())

# Importações necessárias
import requests
from bs4 import BeautifulSoup
from datetime import datetime, date
import json
from babel.dates import format_date, format_datetime, get_day_names
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from dotenv import load_dotenv
import os

# Carregar as variáveis de ambiente
load_dotenv()

"""#Função para Raspagem dos Dados

"""

def raspa_dou():
    try:
        print('Raspando as notícias do dia...')
        page = requests.get('http://www.in.gov.br/leiturajornal')
        soup = BeautifulSoup(page.text, 'html.parser')
        if soup.find("script", {"id": "params"}):
            print('Notícias raspadas')
            return json.loads(soup.find("script", {"id": "params"}).text)
        else:
            print("Elemento script não encontrado.")
            return None
    except requests.RequestException as e:
        print(f"Erro ao fazer a requisição: {e}")
        return None
    except json.JSONDecodeError as e:
        print(f"Erro ao decodificar JSON: {e}")
        return None

# Testar a função de raspagem
conteudo_raspado = raspa_dou()

"""#Função para Formatação da Data"""

def formata_data():
    """

    Returns:

    """
    print('Encontrando a data...')
    data_atual = date.today()
    day_names = get_day_names('wide', locale='pt_BR')
    dia_da_semana = day_names[data_atual.weekday()]
    data_formatada = data_atual.strftime("%d/%m/%Y")
    print('Data encontrada')
    return data_formatada

# Testar a função de formatação da data
data_formatada = formata_data()

"""# Função para Procurar Termos Específicos"""

def procura_termos(conteudo_raspado):
    if 'jsonArray' not in conteudo_raspado:
        print('Formato de dados inesperado.')
        return None

    print('Buscando palavras-chave...')
    palavras_chave = ['Plano Nacional da Educação', 'Infância', 'Saúde', 'Educação', 'Telessaúde Digital', 'Prontuário Eletrônico']
    URL_BASE = 'https://www.in.gov.br/en/web/dou/-/'
    resultados_por_palavra = {palavra: [] for palavra in palavras_chave}
    nenhum_resultado_encontrado = True

    for resultado in conteudo_raspado['jsonArray']:
        item = {
            'section': 'Seção 1',
            'title': resultado.get('title', 'Título não disponível'),
            'href': URL_BASE + resultado.get('urlTitle', ''),
            'abstract': resultado.get('content', ''),
            'date': resultado.get('pubDate', 'Data não disponível')
        }
        for palavra in palavras_chave:
            if palavra.lower() in item['abstract'].lower():
                resultados_por_palavra[palavra].append(item)
                nenhum_resultado_encontrado = False

    if nenhum_resultado_encontrado:
        print(f'Não houve publicação do Diário Oficial da União no dia {data_formatada}. Volte novamente entre segunda e sexta-feira')
        return None

    print('Palavras chaves encontradas')
    return resultados_por_palavra

# Testar a função de busca de termos
palavras_raspadas = procura_termos(conteudo_raspado)

"""#Função para Salvar os Resultados na Base de Dados"""

def salva_na_base(palavras_raspadas):
    """
    Salva os resultados das palavras raspadas em uma planilha do Google Sheets.

    Args:
      palavras_raspadas (dict): Dicionário contendo palavras-chave e seus respectivos resultados raspados.
    """
    if not palavras_raspadas:
        print('Sem palavras encontradas')
        return

    print('Salvando palavras na base de dados...')
    try:
        caminho_credenciais = 'raspagemdou-151e0ee88b03.json'
        scopes = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        conta = ServiceAccountCredentials.from_json_keyfile_name(caminho_credenciais, scopes)

        api = gspread.authorize(conta)
        if not os.getenv('PLANILHA'):
            print('ID da planilha não configurado.')
            return

        planilha = api.open_by_key(os.getenv('PLANILHA'))
        sheet = planilha.worksheet('Página1')

        # Preparar os dados para inserção em lote
        rows_to_append = []
        for palavra, lista_resultados in palavras_raspadas.items():
            for item in lista_resultados:
                if all(k in item for k in ['date', 'title', 'href', 'abstract']):  # Verificar a presença de todos os campos
                    row = [item['date'], palavra, item['title'], item['href'], item['abstract']]
                    rows_to_append.append(row)

        # Inserir os dados em lote se houver linhas para adicionar
        if rows_to_append:
            sheet.append_rows(rows_to_append)
            print(f'{len(rows_to_append)} linhas foram adicionadas à planilha.')
        else:
            print('Nenhum dado válido para salvar.')

    except Exception as e:
        print(f'Erro ao salvar dados: {e}')

# Raspagem dos dados do Diário Oficial da União
conteudo_raspado = raspa_dou()

# Formatação da data atual para uso posterior, se necessário
data_formatada = formata_data()

# Procura por palavras-chave no conteúdo raspado
palavras_raspadas = procura_termos(conteudo_raspado)

# Salva os resultados encontrados na planilha do Google Sheets
salva_na_base(palavras_raspadas)

"""# Função para Enviar Email com os Resultados"""

def envia_email(palavras_raspadas):
    """

    Args:
      palavras_raspadas:
    """
    if not palavras_raspadas:
        print('Sem palavras encontradas')
        return

    print('Enviando e-mail...')
    smtp_server = "smtp-mail.outlook.com"
    port = 587  # Porta para TLS
    email = os.getenv('EMAIL')  # Seu endereço de email do Gmail
    password = os.getenv('SENHA_EMAIL')  # Sua senha de aplicativo

    remetente = email
    destinatarios = os.getenv('DESTINATARIOS').split(',')
    data = datetime.now().strftime('%d/%m/%Y')
    titulo = f'Busca DOU do dia {data}'
    html = f"""<!DOCTYPE html>
    <html>
        <head>
            <title>Busca DOU</title>
        </head>
        <body>
            <h1>Consulta ao Diário Oficial da União</h1>
            <p>As matérias encontradas no dia {data} foram:</p>
    """

    for palavra, lista_resultados in palavras_raspadas.items():
        html += f"<h2>{palavra}</h2>\n"
        if lista_resultados:
            html += "<ul>\n"
            for resultado in lista_resultados:
                html += f"<li><a href='{resultado['href']}'>{resultado['title']}</a></li>\n"
            html += "</ul>\n"
        else:
            html += "<p>Nenhum resultado encontrado para esta palavra-chave.</p>\n"

    html += "</body>\n</html>"

    try:
        server = smtplib.SMTP(smtp_server, port)
        server.starttls()  # Iniciar TLS
        server.login(email, password)  # Autenticar usando sua senha de aplicativo

        mensagem = MIMEMultipart('alternative')
        mensagem["From"] = remetente
        mensagem["To"] = ",".join(destinatarios)
        mensagem["Subject"] = titulo
        conteudo_html = MIMEText(html, "html")
        mensagem.attach(conteudo_html)

        server.sendmail(remetente, destinatarios, mensagem.as_string())
        print('E-mail enviado')
    except Exception as e:
        print(f"Erro ao enviar e-mail: {e}")
    finally:
        server.quit()

envia_email(palavras_raspadas)

"""#TESTE ENVIO"""

import os
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def envia_email_teste():
    print('Preparando para enviar e-mail de teste...')
    smtp_server = "smtp-mail.outlook.com"
    port = 587  # Porta para TLS
    email = os.getenv('EMAIL')  # Seu endereço de email
    destinatario = os.getenv('DESTINATARIOS')
    password = os.getenv('SENHA_EMAIL')  # Sua senha de aplicativo

    remetente = email
    destinatarios = [destinatario]  # Enviar para o próprio remetente como teste

    titulo = 'E-mail de Teste'
    conteudo = "Oi"

    try:
        server = smtplib.SMTP(smtp_server, port)
        server.starttls()  # Iniciar TLS
        server.login(email, password)  # Autenticar usando sua senha de aplicativo

        mensagem = MIMEMultipart('alternative')
        mensagem["From"] = remetente
        mensagem["To"] = ",".join(destinatarios)
        mensagem["Subject"] = titulo
        parte_texto = MIMEText(conteudo, "plain")
        mensagem.attach(parte_texto)

        server.sendmail(remetente, destinatarios, mensagem.as_string())
        print('E-mail de teste enviado com sucesso')
    except Exception as e:
        print(f"Erro ao enviar e-mail de teste: {e}")
    finally:
        server.quit()

# Lembre-se de definir as variáveis de ambiente EMAIL e SENHA_EMAIL antes de executar o código.

# envia_email_teste()